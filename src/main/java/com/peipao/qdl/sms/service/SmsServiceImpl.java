package com.peipao.qdl.sms.service;import com.cloopen.rest.sdk.CCPRestSmsSDK;import com.cloopen.rest.sdk.utils.EncryptUtil;import com.peipao.framework.constant.WebConstants;import com.peipao.framework.util.DateUtil;import com.peipao.framework.util.JsonUtil;import com.peipao.framework.util.PropertiesUtil;import com.peipao.framework.util.ValidateUtil;import com.peipao.qdl.sms.dao.SmsDao;import com.peipao.qdl.sms.model.Sms;import com.peipao.qdl.sms.model.SmsVo;import com.peipao.qdl.sms.model.TemplateSMS;import com.peipao.qdl.sms.model.VoiceCode;import com.peipao.qdl.sms.util.SmsHttpUtil;import net.sf.json.JSONObject;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.util.EntityUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.BoundValueOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Random;import java.util.concurrent.TimeUnit;import java.util.regex.Matcher;import java.util.regex.Pattern;@Servicepublic class SmsServiceImpl implements SmsService {    private String version = PropertiesUtil.getProperty(WebConstants.SMS.PROPERTY_FILE, WebConstants.SMS.VERSION);    private String accountSid = PropertiesUtil.getProperty(WebConstants.SMS.PROPERTY_FILE, WebConstants.SMS.ACCOUNT_ID);    private String appId = PropertiesUtil.getProperty(WebConstants.SMS.PROPERTY_FILE, WebConstants.SMS.APP_ID);    private String authToken = PropertiesUtil.getProperty(WebConstants.SMS.PROPERTY_FILE, WebConstants.SMS.AUTH_TOKEN);//    private String server = PropertiesUtil.getProperty(WebConstants.SMS.SERVER, WebConstants.SMS.SERVER);    public String smsValidTime ="10分钟";    private String templateId = PropertiesUtil.getProperty(WebConstants.SMS.PROPERTY_FILE, "templateId");//验证码短信模板ID    private String repairTemplateId = PropertiesUtil.getProperty(WebConstants.SMS.PROPERTY_FILE, "repairTemplateId");//网络报修代报短信模板ID    @Autowired    private SmsDao dao;    @Autowired    private RedisTemplate redisTemplate;    /**     * 发送短信验证码     *     * @param phone     * @return     * @throws Exception     */    public String sendVerificationCode(String phone) throws Exception {        if (!ValidateUtil.isMobile(phone))            throw new Exception("错误的手机号码");        Random random = new Random();        String veriCode = Integer.toString(random.nextInt(899999) + 100000);        pushSms(phone, veriCode);        //放入内存        SmsVo vo = new SmsVo();        vo.setPhone(phone);        vo.setExpireTime(DateUtil.getDateAfterMinutes(new Date(), 30));        vo.setCode(veriCode);        //写入redis 设置有效期        String key = "verifyCode:"+phone;        BoundValueOperations<String, String> ops = redisTemplate.boundValueOps(key);        ops.set(veriCode);        redisTemplate.expire(key,60*30,TimeUnit.SECONDS);        SmsService.smsMap.put(phone, vo);        verifyCode(phone, veriCode);        return veriCode;    }    private HashMap<String, Object> verifyCode(String mobile, String code) {        HashMap<String, Object> result = null;        CCPRestSmsSDK restAPI = new CCPRestSmsSDK();        //app.cloopen.com 正式环境        //初始化服务地址和端口,地址须为 sandboxapp.cloopen.com 测试环境,,,无需带协议头，目前默认是https协议        restAPI.init("app.cloopen.com", "8883");// 初始化服务器地址和端口，格式如下，服务器地址不需要写https://        restAPI.setAccount("8a48b551510f653b0151134996f80cb8", "5a05f7a5422f4a948326aeceb520de0c");// 初始化主帐号和主帐号TOKEN        restAPI.setAppId("aaf98f89510f639f0151134c2e0e0b94");// 初始化应用ID        result = restAPI.sendTemplateSMS(mobile, templateId, new String[]{code, smsValidTime});        //System.out.println("SDKTestSendTemplateSMS result=" + result);        if("000000".equals(result.get("statusCode"))){            //正常返回输出data包体信息（map）			/*HashMap<String,Object> data = (HashMap<String, Object>) result.get("data");			Set<String> keySet = data.keySet();			for(String key:keySet){				Object object = data.get(key);				System.out.println(key +" = "+object);*/            result.put("verifycode", code);            //return result;        }        //异常返回输出错误码和错误信息        //System.out.println("错误码=" + result.get("statusCode") +" 错误信息= "+result.get("statusMsg"));        return result;    }    /**     * 发送报修代报短信     *     * @param phone     * @param name     * @param context     * @param repairNo     * @return     * @throws Exception     */    public String sendRepairCode(String phone, String name, String context, String repairNo) throws Exception {        if (!ValidateUtil.isMobile(phone)) {            throw new Exception("错误的手机号码");        }        Random random = new Random();        String veriCode = Integer.toString(random.nextInt(899999) + 100000);        pushRepairSms(phone, name, context, repairNo);        //放入内存        SmsVo vo = new SmsVo();        vo.setPhone(phone);        vo.setExpireTime(DateUtil.getDateAfterMinutes(new Date(), 30));        vo.setCode(veriCode);        SmsService.smsMap.put(phone, vo);        return veriCode;    }    public List<Sms> getSms(int status) throws Exception {        List<Sms> sms = dao.getSms(status);        return sms;    }    public void updateSms(Sms sms) throws Exception {        dao.updateSms(sms);    }    public void pushSms(String phone, String veriCode) throws Exception {        int minutesExpire = 30;        String content = veriCode + "," + minutesExpire;        Sms sms = new Sms(templateId, phone, content);        dao.insertSms(sms);    }    public void pushRepairSms(String phone, String name, String context, String repairNo) throws Exception {        StringBuilder sb = new StringBuilder();        sb.append(name).append(",").append(context).append(",").append(repairNo).append(",").append(repairNo);        Sms sms = new Sms(repairTemplateId, phone, sb.toString());        dao.insertSms(sms);    }    public static boolean isMobileNO(String mobiles) {        Pattern p = Pattern.compile("\\d{11}$");        Matcher m = p.matcher(mobiles);        return m.matches();    }    public static boolean isEmail(String email) {        String str = "^([a-zA-Z0-9]*[-_]?[a-zA-Z0-9]+)*@([a-zA-Z0-9]*[-_]?[a-zA-Z0-9]+)+[\\.][A-Za-z]{2,3}([\\.][A-Za-z]{2})?$";        Pattern p = Pattern.compile(str);        Matcher m = p.matcher(email);        return m.matches();    }    public String sendSMS(String templateId, Sms sms) throws Exception {        String result = "";        DefaultHttpClient httpclient = new DefaultHttpClient();        try {            // MD5加密            EncryptUtil encryptUtil = new EncryptUtil();            // 构造请求URL内容            String timestamp = DateUtil.dateToStr(new Date(), DateUtil.DATE_TIME_NO_SLASH);// 时间戳            String signature = SmsHttpUtil.getSignature(accountSid, authToken, timestamp, encryptUtil);            String url = SmsHttpUtil.getStringBuffer().append("/").append(version).append("/Accounts/")                    .append(accountSid).append("/Messages/templateSMS").append("?sig=").append(signature).toString();            TemplateSMS templateSMS = new TemplateSMS();            templateSMS.setAppId(appId);            templateSMS.setTemplateId(templateId);            templateSMS.setTo(sms.getPhone());            templateSMS.setParam(sms.getContent());            JsonUtil jsonUtil = new JsonUtil();            String body = jsonUtil.toJson(templateSMS);            body = "{\"templateSMS\":" + body + "}";            HttpResponse response = SmsHttpUtil.post("application/json", accountSid, authToken, timestamp, url,                    httpclient, encryptUtil, body);            HttpEntity entity = response.getEntity();            if (entity != null) {                result = EntityUtils.toString(entity, "UTF-8");            }            JSONObject a = JSONObject.fromObject(result);            int respCode = a.getJSONObject("resp").getInt("respCode");            if (respCode != 0) {                if (sms.getSendCount() == 3) {                    sms.setStatus(Sms.STATUS.FAIL.ordinal());                    dao.updateSms(sms);                }                if (sms.getSendCount() < 3) {                    sms.setSendCount(sms.getSendCount() + 1);                    dao.updateSms(sms);                }            } else {                sms.setSendTime(new Date());                sms.setStatus(Sms.STATUS.SENT.ordinal());                dao.updateSms(sms);            }            EntityUtils.consume(entity);        } catch (Exception e) {            e.printStackTrace();            throw new Exception(e.toString());        } finally {            // 关闭连接            httpclient.getConnectionManager().shutdown();        }        return result;    }    public String voiceCode(String to, String verifyCode) throws Exception {        // TODO Auto-generated method stub        String result = "";        DefaultHttpClient httpclient = new DefaultHttpClient();        try {            // MD5加密            EncryptUtil encryptUtil = new EncryptUtil();            // 构造请求URL内容            String timestamp = DateUtil.dateToStr(new Date(), DateUtil.DATE_TIME_NO_SLASH);// 时间戳            String signature = SmsHttpUtil.getSignature(accountSid, authToken, timestamp, encryptUtil);            String url = SmsHttpUtil.getStringBuffer().append("/").append(version).append("/Accounts/")                    .append(accountSid).append("/Calls/voiceCode").append("?sig=").append(signature).toString();            VoiceCode voiceCode = new VoiceCode();            voiceCode.setAppId(appId);            voiceCode.setVerifyCode(verifyCode);            voiceCode.setTo(to);            JsonUtil jsonUtil = new JsonUtil();            String body = jsonUtil.toJson(voiceCode);            body = "{\"voiceCode\":" + body + "}";            HttpResponse response = SmsHttpUtil.post("application/json", accountSid, authToken, timestamp, url,                    httpclient, encryptUtil, body);            HttpEntity entity = response.getEntity();            if (entity != null) {                result = EntityUtils.toString(entity, "UTF-8");            }            EntityUtils.consume(entity);        } catch (Exception e) {            throw new Exception(e.toString());        } finally {            // 关闭连接            httpclient.getConnectionManager().shutdown();        }        return result;    }}